optimizedReadInto: string startingAt: offset count: requestedCount fromStream: stream	"Read requestedCount characters into string starting at offset,	returning the number read, there could be less available when stream is atEnd"	"Optimize based on the assumption that most encoded characters will be ASCII"		| byteBuffer bytesRead read last next count readStream bytesLeft |	"Start by reading the minimum amount of bytes for encoding requestedCount characters"	byteBuffer := ByteArray new: requestedCount.	bytesRead := stream readInto: byteBuffer startingAt: 1 count: requestedCount.	readStream := byteBuffer readStream.	read := 0.	last := offset.	next := self findFirstNonASCIIIn: byteBuffer startingAt: last.	(next = 0 or: [ bytesRead < next ]) 		ifTrue: [			"The whole input is ASCII"			self replace: string from: offset to: offset + bytesRead - 1 with: byteBuffer startingAt: 1. 			^ bytesRead ].	[	next > last 			ifTrue: [				"Copy the ASCII run from last to next"				count := next - last.				self replace: string from: offset + read to: offset + read + count - 1 with: byteBuffer startingAt: last.				read := read + count ].		"Read one UTF-8 encoded non ASCII character"		readStream position: next - 1.		count := self encodingLengthFor: readStream peek.		bytesLeft := bytesRead - next + 1.		count <= bytesLeft			ifTrue: [ 				string at: offset + read put: (self nextFromStream: readStream) ]			ifFalse: [ | tmpBuffer extraRead |				tmpBuffer := ByteArray new: count.				readStream readInto: tmpBuffer startingAt: 1 count: bytesLeft.				extraRead := stream readInto: tmpBuffer startingAt: bytesLeft + 1 count: count - bytesLeft.				extraRead = (count - bytesLeft) ifFalse: [ self error: 'incomplete utf-8 encoding' ].				string at: offset + read put: (self nextFromStream: tmpBuffer readStream) ].		last := next + count.		read := read + 1.		"Iterate"		next := self findFirstNonASCIIIn: byteBuffer startingAt: last.		next = 0 or: [ bytesRead < next ] ] whileFalse.	bytesRead < last 		ifFalse: [			"There is a last ASCII run left" 			count := bytesRead - last + 1.			self replace: string from: offset + read to: offset + read + count - 1 with: byteBuffer startingAt: last.			read := read + count ].	"Try consuming enough input to reach requestedCount since we probably read too little"	count := 	requestedCount - read.	^ read + (super readInto: string startingAt: offset + read count: count fromStream: stream)